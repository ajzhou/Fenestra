float val(vec4 p) {
    if (p.r == 0.0 && p.g == 0.0) return 0.0;
    if (p.r != 0.0) return p.a;
    if (p.g != 0.0) return -p.g;

    return 0.0;
}

float roundNum(float x){
    if (mod(x,1.0) < 0.5) return floor(x);
    return ceil(x);
}

float gaussianWeight(float x, float y, float sigma){
    const float M_PI = 3.1415926535897932384626433832795;
    return (1.0/((2.0 * M_PI) * sigma * sigma)) * exp(-1.0 * ((x * x) + (y * y)) / (2.0 * (sigma * sigma)));
}

kernel vec4 findPeak(sampler kp, sampler mn, float sigma)
{
    float radius   = roundNum(3.0 * sigma);
    float M_PI     = 3.14159265358979323846264338327950288;
    vec4 BLACK     = vec4(0.0, 0.0, 0.0, 1.0);
    vec4 extent    = samplerExtent(mn);

    vec2 dc        = destCoord();
    vec4 indicator = sample(kp, samplerTransform(kp, dc));
    if (val(indicator) == 0.0) return BLACK;

    float bin[36];

    for (float x=-radius; x<=radius; x+=1.0){
        for (float y=-radius; y<=radius; y+=1.0){
            vec2 offset = vec2(x,y);
            vec2 nc = dc + offset;
            if (nc.x < extent[0] || nc.x >= extent[0]+extent[2]) {
                offset = vec2(-x,y);
                nc = dc + offset;
            }
            if (nc.y < extent[1] || nc.y >= extent[1]+extent[3]) {
                offset = vec2(x,-y);
                nc = dc + offset;
            }

            vec4 p  = sample(mn, samplerTransform(mn, nc));
            float m = p[0];
            float o = p[1];
            float g = gaussianWeight(x, y, sigma);
            int index = int(floor(o * 36.0));
            bin[index] += m * g;
        }
    }

    float max = -1.0;
    float peak = 0.0;
    for (int i = 0; i < 36; i++) {
        if (bin[i] > max) {
            peak = float(i+1) * 10.0;
            max = bin[i];
        }
    }

    return vec4(peak / 360.0, 0.0, 0.0, 1.0);
}
