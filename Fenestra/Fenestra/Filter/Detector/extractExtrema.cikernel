// ExtractExtrema code for grayscale images
kernel vec4 extractExtrema(sampler src, sampler comparison1, sampler comparison2)
{
    vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);

    vec2 dc = destCoord();
    vec4 p  = sample(src, samplerTransform(src, dc));

    if (p.r == 0.0 && p.g == 0.0) return BLACK;


    // check max in R channel
    if (p.r != 0.0) {
        float sum = 0.0;
        for (int i = -1; i <= 1; i++ ) {
            for (int j = -1; j <= 1; j++){
                vec2 offset = vec2(float(i),float(j));
                vec2 nc = dc + offset;

                // check out of bounds; reflect back if out of bounds
                vec4 extent = samplerExtent(src);
                if (nc.x<extent[0] || nc.y<extent[1] || nc.x>=(extent[0]+extent[2]) || nc.y>=(extent[1]+extent[3])) nc = dc - offset;

                // if it is not maximum, return BLACK
                float comp1    = sample(comparison1, samplerTransform(comparison1, nc)).r;
                float comp2    = sample(comparison2, samplerTransform(comparison2, nc)).r;
                float compSelf = sample(src, samplerTransform(src, nc)).r;
                if (i==0 && j==0) { // do not compare self at origin
                    sum = sum + comp1 + comp2;
                    if (comp1 >= p.r || comp2 >= p.r) return BLACK;
                } else {
                    sum = sum + comp1 + comp2 + compSelf;
                    if (comp1 >= p.r || comp2 >= p.r || compSelf >= p.r) return BLACK;
                }
            }
        }
        // found max in red channel, reject low contrast
        float avg = sum / 26.0;
        if (p.r - avg > 0.015 && p.r > 0.03) return p;
    } else { // check max in green channel; equivalent of finding minimum
        float sum = 0.0;
        for (int i = -1; i <= 1; i++ ) {
            for (int j = -1; j <= 1; j++){
                vec2 offset = vec2(i,j);
                vec2 nc = dc + offset;

                // check out of bounds; reflect back if out of bounds
                vec4 extent = samplerExtent(src);
                if (nc.x<extent[0] || nc.y<extent[1] || nc.x >= extent[0]+extent[2] || nc.y >=extent[1]+extent[3]) nc = dc - offset;

                // if it is not maximum, return BLACK
                float comp1    = sample(comparison1, samplerTransform(comparison1, nc)).g;
                float comp2    = sample(comparison2, samplerTransform(comparison2, nc)).g;
                float compSelf = sample(src, samplerTransform(src, nc)).g;
                if (i==0 && j==0) { // do not compare self at origin
                    sum = sum + comp1 + comp2;
                    if (comp1 >= p.g || comp2 >= p.g) return BLACK;
                } else {
                    sum = sum + comp1 + comp2 + compSelf;
                    if (comp1 >= p.g || comp2 >= p.g || compSelf >= p.g) return BLACK;
                }
            }
        }
        // reject low contrast
        float avg = sum / 26.0; // 26 neighbors
        if (p.g - avg > 0.015 && p.g > 0.03) return p;
    }

    return BLACK; // safe condition
}

