float dx(sampler src, vec2 dc) {
vec4 extent = samplerExtent(src);
float xLo = dc.x - 1;
if (xLo < extent[0]) xLo = dc.x;
float xHi = dc.x + 1;
if (xHi > (extent[0] + extent[2])) xHi = dc.x;

return sample(src, samplerTransform(src, vec2(xHi, dc.y))).a - sample(src, samplerTransform(src, vec2(xLo, dc.y))).a;

}

float dy(sampler src, vec2 dc) {
vec4 extent = samplerExtent(src);
float yLo = dc.y - 1;
if (yLo < extent[1]) yLo = dc.y;
float yHi = dc.y + 1;
if (yHi >= (extent[1] + extent[3])) yHi = dc.y;

return sample(src, samplerTransform(src, vec2(dc.x, yHi))).a - sample(src, samplerTransform(src, vec2(dc.x, yLo))).a;

}


kernel vec4 edgeRejection(sampler map, sampler src, float r)
{
vec2 dc = destCoord();
vec4 indicator = sample(map, samplerTransform(map, dc));

if (indicator.a == 0.0) return vec4(0.0);

vec4 extent = samplerExtent(src);

// find dxx
float xLo = dc.x - 1;
if (xLo < extent[0]) xLo = dc.x;
float xHi = dc.x + 1;
if (xHi > (extent[0] + extent[2])) xHi = dc.x;

float dxx = dx(src, vec2(xHi,dc.y)) - dx(src, vec2(xLo,dc.y));


// find dyy
float yLo = dc.y - 1;
if (yLo < extent[1]) yLo = dc.y;
float yHi = dc.y + 1;
if (yHi >= (extent[1] + extent[3])) yHi = dc.y;

float dyy = dy(src, vec2(dc.x, yHi)) - dy(src, vec2(dc.x, yLo));

// find dxy
float dxy = dx(src, vec2(dc.x, yHi)) - dx(src, vec2(dc.x, yLo));


// find trace and determinant of Hessian
float trace = dxx + dyy;
float det = dxx * dyy - dxy * dxy;

// check principal curvature ratio
float ratio = trace * trace / det;
float threshold = (r + 1) * (r + 1) / r;
if (ratio > threshold) return vec4(0.0);

return indicator;

}

