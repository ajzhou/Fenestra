// ExtractExtrema code for grayscale images
kernel vec4 extractExtrema(sampler src, sampler comparison1, sampler comparison2, float sigma)
{
    vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);

    vec2 dc = destCoord();
    vec4 p  = sample(src, samplerTransform(src, dc));

    if (p.r == 0.0 && p.g == 0.0) return BLACK;


    // check max through R channel
    if (p.r != 0.0) {
        for (int i = -1; i <= 1; i++ ) {
            for (int j = -1; j <= 1; j++){
                vec2 offset = vec2(float(i),float(j));
                vec2 nc = dc + offset;

                // check out of bounds; reflect back if out of bounds
                vec4 extent = samplerExtent(src);
                if (nc.x<extent[0] || nc.y<extent[1] || nc.x>=(extent[0]+extent[2]) || nc.y>=(extent[1]+extent[3])) nc = dc - offset;

                // if it is not maximum, return BLACK
                float comp1    = sample(comparison1, samplerTransform(comparison1, nc)).r;
                float comp2    = sample(comparison2, samplerTransform(comparison2, nc)).r;
                float compSelf = sample(src, samplerTransform(src, nc)).r;
                if (i==0 && j==0) { // do not compare self at origin
                    if (comp1 > p.r || comp2 > p.r) return BLACK;
                } else {
                    if (comp1 > p.r || comp2 > p.r || compSelf > p.r) return BLACK;
                }
            }
        }
        // found max in red channel
        return p;
    } else { // check max in green channel; equivalent of finding minimum
        for (int i = -1; i <= 1; i++ ) {
            for (int j = -1; j <= 1; j++){
                vec2 offset = vec2(i,j);
                vec2 nc = dc + offset;

                // check out of bounds; reflect back if out of bounds
                vec4 extent = samplerExtent(src);
                if (nc.x<extent[0] || nc.y<extent[1] || nc.x >= extent[0]+extent[2] || nc.y >=extent[1]+extent[3]) nc = dc - offset;

                // if it is not maximum, return BLACK
                float comp1    = sample(comparison1, samplerTransform(comparison1, nc)).g;
                float comp2    = sample(comparison2, samplerTransform(comparison2, nc)).g;
                float compSelf = sample(src, samplerTransform(src, nc)).g;
                if (i==0 && j==0) { // do not compare self at origin
                    if (comp1 > p.g || comp2 > p.g) return BLACK;
                } else {
                    if (comp1 > p.g || comp2 > p.g || compSelf > p.r) return BLACK;
                }
            }
        }
        // found max in green channel
        return p;
    }

    return BLACK; // safe condition
}

